##### 其實前面是談過一次daemon進程的，但是並涉及過多原理，但是並不影響使用。今天打算說說關於daemon進程更多的二三事，本質上說，如果你僅僅是簡單實現利用一下daemon進程，這個不看也是可以的。
##### 杠真，*NIX真是波大精深，越是深入看越是發現它的diao。原理往往都是枯燥的，大家都不愛看，但這並不影響我堅持寫自己對這些東西的理解。 
##### 三個概念，理（bei）解（song）一下：
- 進程組。一坨相關的進程可以組成一個進程組，每個進程組都會有一個組ID（正整數），每個進程組都會有一個組長進程，組長進程的ID等於進程組ID。組長進程可以創建新的進程組以及該進程組中的其他進程。一個進程組的是有生命周期的，即便是組長進程掛了，只有組裡還有其他的活口，那就就算該進程組依然存活，只有到組裡最後一個活口也掛了，那真的就是徹底沒了。
- 會話。一坨相關的進程組組成了一個會話。在*NIX下，是通過setsid()創建一個新的會話。但是值得注意的是，組長進程不能創建會話，簡單理解就是在組長進程中，執行setsid函數會報錯，這點很重要。所以一般都是組長進程執行fork，然後主進程退出，因為子進程的進程ID是新分配的，而子進程的進程組ID是繼承父進程的，所以子進程就注定不可能是組長進程，從而可以確保子進程中一定可以執行setsid函數。在執行setsid函數時候，一般會發生下面三個比較重要的事情：
  - 該進程會創建一個新的進程組，該進程為進程組組長（或者你可以認為這是一種提升）
  - 該進程會創建一個會話組並成為該會話的會話首進程（會話首進程就是創建該會話的進程）
  - 該進程會失去控制終端。如果該進程本來就沒有控制終端，則罷了（liao）。如果有，那麼該進程也將脫離該控制終端，與之失去聯系。
- 控制終端。每個會話可能會擁有一個控制終端（看著比較玄學，你可以暫時理解為就一個那種黑乎乎的命令行窗口），建立與控制終端連接的會話首進程叫做控制進程。

##### 結合Linux命令ps來查看一下上述幾個概念的恩怨情仇，我們看下我們常用的 ps -o pid,ppid,pgid,sid,comm | less 執行結果：
![](http://static.ti-node.com/6379944793014796288)
##### 第一行分別是PID，PPID，PGID，SID，COMMAND，依次分別是進程ID，該進程父進程ID，進程組ID，會話ID，命令。
##### 通過最後一列，我們知道第二行就是bash也就是bash shell進程，其進程ID為15793，其父進程為13291，進程組ID為15793，會話ID也會15793，結合前面的概念，我們可以知道bash shell就是該進程組組長。
##### 第三行則是ps命令的進程，其進程ID為15816，他是由於bash進程fork出來的，所以他的父進程ID為15793，然後是他所屬的組ID為15816，所屬的會話ID依然是15793。
##### 最後一行是less命令的進程，其進程ID為15817，他也是由bash進程fork出來的，所以他的父進程ID也為15793，然後是他所屬的組ID為15816，所屬的會話ID依然是15793。
##### 簡單總結一下：
- 上述三個進程一共形成了兩個進程組，bash自己為一組，組ID為15793，組長進程為bash自己 ; ps和less為一組，組ID為15816，組長進程為ps進程
- 上述三個進程屬於同一個會話，會話ID為15793，會話首進程為bash進程（待定）
- 控制終端則為打開的terminal窗口，與之關聯的控制進程則為bash進程

##### 通過這麼一頓分析，是不是感覺可以接受點兒了？然後是，叨逼叨了半天這個，跟daemon進程有啥子關系？
##### 啦啦啦，下面通過引入代碼直接分析：
```php
$pid = pcntl_fork();
if( $pid < 0 ){
  exit('fork error.');
} else if( $pid > 0 ) {
  // 主進程退出
  exit();
}
// 子進程繼續執行

// 最關鍵的一步來了，執行setsid函數！
if( !posix_setsid() ){
  exit('setsid error.');
}

// 理論上一次fork就可以了
// 但是，二次fork，這裡的歷史淵源是這樣的：在基於system V的系統中，通過再次fork，父進程退出，子進程繼續，保證形成的daemon進程絕對不會成為會話首進程，不會擁有控制終端。

$pid = pcntl_fork();
if( $pid  < 0 ){
  exit('fork error');
} else if( $pid > 0 ) {
  // 主進程退出
  exit;
}

// 子進程繼續執行

// 啦啦啦，啦啦啦，啦啦啦，已經變成daemon啦，開心
cli_set_process_title('testtesttest');
// 睡眠1000000，防止進程執行完畢掛了
sleep( 1000000 );

```
##### 將上述文件保存為daemon.php，然後php daemon.php執行，使用 ps -aux | grep testte ，如果沒有什麼大問題你應該就可以看到這個進程在後台跑了。

##### 所以為什麼第一步要先fork呢？因為調用setsid的進程不可以是組長進程（篇頭的枯燥知識需要了吧？），所以必須fork一次，然後將主進程直接退出，保留子進程。因為子進程一定不會是組長進程，所以子進程可以調用setsid。調用setsid則會產生三個現像：創建一個新會話並成為會話首進程，創建一個進程組並成為組長進程，脫離控制終端。
##### 啦啦啦，明白為啥篇頭那一坨枯燥的知識是為了什麼吧？
##### 然而，實際上，上述代碼僅僅完成了一個標准daemon的80%，還有20%需要我們進一步完善。那麼，需要完善什麼呢？我們修改一下上述代碼，讓程序在最終的代碼段中執行一些文本輸出：
```php
$pid = pcntl_fork();
if( $pid < 0 ){
  exit('fork error.');
} else if( $pid > 0 ) {
  // 主進程退出
  exit();
}
// 子進程繼續執行

// 最關鍵的一步來了，執行setsid函數！
if( !posix_setsid() ){
  exit('setsid error.');
}

// 理論上一次fork就可以了
// 但是，二次fork，這裡的歷史淵源是這樣的：在基於system V的系統中，通過再次fork，父進程退出，子進程繼續，保證形成的daemon進程絕對不會成為會話首進程，不會擁有控制終端。

$pid = pcntl_fork();
if( $pid  < 0 ){
  exit('fork error');
} else if( $pid > 0 ) {
  // 主進程退出
  exit;
}

// 子進程繼續執行

// 啦啦啦，啦啦啦，啦啦啦，已經變成daemon啦，開心
cli_set_process_title('testtesttest');
// 循環1000次，每次睡眠1s，輸出一個字符test
for( $i = 1; $i <= 1000; $i++ ){
  sleep( 1 );
  echo "test".PHP_EOL;
}
```
##### 將文件保存為daemon.php，然後php daemon.php執行文件，嗯，是不是有怪怪的現像，大概類似於下圖：
![](http://static.ti-node.com/6379961708575719424)
##### 即便你按Ctrl+C都沒用，終端在不斷輸出test，唯一辦法就是關閉當前終端窗口然後重新開一個，然而，這並不符合社會主義主流價值觀。所以，我們還要解決標准輸出和錯誤輸出，我們的daemon程序不可以再將終端窗口當作默認的標准輸出了。
##### 其次是將當前工作目錄修改更改為根目錄。不然可能就會出現下面這樣一個問題，就是如果父進程是的工作目錄是一個掛載的目錄，那麼子進程會繼承父進程的工作目錄，當子進程已經daemon化後就會出現一個悲劇：那就是雖然原來掛載的目錄已經不用了，但是卻無法用umount卸載，非常悲劇。
##### 最後一個問題是，要在第一次fork後設置umask(0)，避免權限上的一些問題。所以較為完整的代碼如下：
```php
// 設置umask為0，這樣，當前進程創建的文件權限則為777
umask( 0 );

$pid = pcntl_fork();
if( $pid < 0 ){
  exit('fork error.');
} else if( $pid > 0 ) {
  // 主進程退出
  exit();
}
// 子進程繼續執行

// 最關鍵的一步來了，執行setsid函數！
if( !posix_setsid() ){
  exit('setsid error.');
}

// 理論上一次fork就可以了
// 但是，二次fork，這裡的歷史淵源是這樣的：在基於system V的系統中，通過再次fork，父進程退出，子進程繼續，保證形成的daemon進程絕對不會成為會話首進程，不會擁有控制終端。

$pid = pcntl_fork();
if( $pid  < 0 ){
  exit('fork error');
} else if( $pid > 0 ) {
  // 主進程退出
  exit;
}

// 子進程繼續執行

// 啦啦啦，啦啦啦，啦啦啦，已經變成daemon啦，開心
cli_set_process_title('testtesttest');
// 一般服務器軟件都有寫配置項，比如以debug模式運行還是以daemon模式運行。如果以debug模式運行，那麼標准輸出和錯誤輸出大多數都是直接輸出到當前終端上，如果是daemon形式運行，那麼錯誤輸出和標准輸出可能會被分別輸出到兩個不同的配置文件中去
// 連工作目錄都是一個配置項目，通過php函數chdir可以修改當前工作目錄
chdir( $dir );

```

---
