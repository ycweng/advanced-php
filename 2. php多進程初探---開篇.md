實際上PHP是有多線程的，只是很多人不常用。使用PHP的多線程首先需要下載安裝一個線程安全版本（ZTS版本）的PHP，然後再安裝pecl的[pthread擴展](http://pecl.php.net/package/pthreads "pthread擴展")。

實際上PHP是有多進程的，有一些人再用，總體來說php的多進程還算湊合，只需要在安裝PHP的時候開啟pcntl模塊（是不是跟UNIX中的fcntl有點兒.... ....）即可。在*NIX下，在終端命令行下使用php -m就可以看到是否開啟了pcntl模塊。

所以我們只說php的多進程，至於php多線程就暫時放到一邊兒。

**注意：不要在apache或者fpm環境下使用php多進程，這將會產生不可預估的後果。**

**進程是程序執行的實例**，舉個例子有個程序叫做 “ 病毒.exe ”，這個程序平時是以文件形式存儲在硬盤上，當你雙擊運行後，就會形成一個該程序的進程。系統會給每一個進程分配一個唯一的非負整數用來標記進程，這個數字稱作進程ID。當該進程被殺死或終止後，其進程ID就會被系統回收，然後分配給新的其余的進程。

說了這麼多，這鬼東西有什麼用嗎？我平時用CI、YII寫個CURD跟這個也沒啥關聯啊。實際上，如果你了解APACHE PHP MOD或者FPM就知道這些東西就是多進程實現的。以FPM為例，一般都是nginx作為http服務器擋在最前面，靜態文件請求則nginx自行處理，遇到php動態請求則轉發給php-fpm進程來處理。如果你的php-fpm配置只開了5個進程，如果處理任意一個用戶的請求都需要1秒鐘，那麼5個fpm進程1秒中就最多只能處5個用戶的請求。所以結論就是：如果要單位時間內干活更快更多，就需要更多的進程，總之一句話就是多進程可以加快任務處理速度。

在php中我們使用pcntl_fork()來創建多進程（在*NIX系統的C語言編程中，已有進程通過調用fork函數來產生新的進程）。fork出來新進程則成為子進程，原進程則成為父進程，子進程擁有父進程的副本。這裡要注意：
- 子進程與父進程共享程序正文段
- 子進程擁有父進程的數據空間和堆、棧的副本，注意是副本，不是共享
- 父進程和子進程將繼續執行fork之後的程序代碼
- fork之後，是父進程先執行還是子進程先執行無法確認，取決於系統調度（取決於信仰）

這裡說子進程擁有父進程數據空間以及堆、棧的副本，實際上，在大多數的實現中也並不是真正的完全副本。更多是采用了COW（Copy On Write）即寫時復制的技術來節約存儲空間。簡單來說，如果父進程和子進程都不修改這些 數據、堆、棧 的話，那麼父進程和子進程則是暫時共享同一份 數據、堆、棧。只有當父進程或者子進程試圖對 數據、堆、棧 進行修改的時候，才會產生復制操作，這就叫做寫時復制。

在調用完pcntl_fork()後，該函數會返回兩個值。在父進程中返回子進程的進程ID，在子進程內部本身返回數字0。由於多進程在apache或者fpm環境下無法正常運行，所以大家一定要在php cli環境下執行下面php代碼。

第一段代碼，我們來說明在程序從pcntl_fork()後父進程和子進程將各自繼續往下執行代碼：
```php
<?php
        $pid = pcntl_fork();
	if( $pid > 0 ){
            echo "我是父親".PHP_EOL;
	} else if( 0 == $pid ) {
            echo "我是兒子".PHP_EOL;
	} else {
            echo "fork失敗".PHP_EOL;
        }
```
將文件保存為test.php，然後在使用cli執行，結果如下圖所示：
![](https://static.ti-node.com/6374508376738496512)

第二段代碼，用來說明子進程擁有父進程的數據副本，而並不是共享：
```php
<?php
        // 初始化一個 number變量 數值為1
        $number = 1;
	$pid = pcntl_fork();
	if( $pid > 0 ){
            $number += 1;
            echo "我是父親，number+1 : { $number }".PHP_EOL;
	} else if( 0 == $pid ) {
	    $number += 2;
            echo "我是兒子，number+2 : { $number }".PHP_EOL;
	} else {
            echo "fork失敗".PHP_EOL;
        }
```
![](https://static.ti-node.com/6374520918680535040)

第三段代碼，比較容易讓人思維混亂，pcntl_fork()配合for循環來做些東西，問題來了：會顯示幾次 “ 兒子 ”？
```php
<?php
        for( $i = 1; $i <= 3 ; $i++ ){
	    $pid = pcntl_fork();
	    if( $pid > 0 ){
	        // do nothing ...
	    } else if( 0 == $pid ){
		echo "兒子".PHP_EOL;
	    }
	}
```
上面代碼執行結果如下：
![](https://static.ti-node.com/6374530342694420480)

仔細數數，竟然是顯示了7次 “ 兒子 ”。好奇怪，難道不是3次嗎？... ...
下面我修改一下代碼，結合下面的代碼，再思考一下為什麼會產生7次而不是3次。
```php
<?php
        for( $i = 1; $i <= 3 ; $i++ ){
            $pid = pcntl_fork();
	    if( $pid > 0 ){
	        // do nothing ...
	    } else if( 0 == $pid ){
	        echo "兒子".PHP_EOL;
		exit;
	    }
	}
```
執行結果如下圖所示：
![](https://static.ti-node.com/6374530960842555392)

前面強調過：**父進程和子進程將繼續執行fork之後的程序代碼(包含pcntl_fork函數)**。這裡就不解釋，實在想不明白的，可以動手自己畫畫思考一下。

___
這裡應該還是要解釋一波的
* i=1的時候父進程的pid不為0 這時候fork了一個pid=0的子進程a, 子進程數量1
* i=2的時候父進程fork了一個子進程b, 子進程a又fork了一個子進程c, 子進程數量1+2
* i=3的時候父進程fork了一個子進程d, a子進程fork了e, b子進程fork了f, c子進程fork了g子進程數量1+2+4=7

* 至於在fork子進程退出的時候 i=1 =2 =3的時候都只有一個父進程fork一個子進程 所以只有三個兒子
___

為了避免寫成臭尾理論文兒，這裡強行斷篇分割一下，下一章說僵屍進程和孤兒進程的一些恩怨情仇。

-----
感謝workerman1群成員“小菜鳥”（不是我叫TA小菜鳥，是TA昵稱就是小菜鳥）指出錯誤～
